# ========================================
# EKS DEPLOYMENT MODULE
# ========================================
# This module orchestrates the complete EKS deployment including:
# - VPC Discovery
# - Bastion Host (optional)
# - EKS Cluster
# - Node Groups
# - EKS Addons
# - Monitoring Stack (optional)

# Terraform providers are generated by Terragrunt root configuration

# ========================================
# AUTO-DISCOVERY DATA SOURCES
# ========================================

# Auto-discover VPC by name if not provided
data "aws_vpc" "by_name" {
  count = var.vpc_id == "" && var.vpc_name != "" ? 1 : 0
  
  filter {
    name   = "tag:Name"
    values = [var.vpc_name]
  }
  
  filter {
    name   = "state"
    values = ["available"]
  }
}

# Auto-discover default VPC if no name provided
data "aws_vpc" "default" {
  count   = var.vpc_id == "" && var.vpc_name == "" ? 1 : 0
  default = true
}

# Auto-discover KMS key by alias name if not provided (only when encryption is enabled)
data "aws_kms_alias" "by_name" {
  count = var.enable_cluster_encryption && var.kms_key_arn == "" && var.kms_key_alias != "" ? 1 : 0
  name  = var.kms_key_alias
}

# Auto-discover default EKS KMS key if no alias provided (only when encryption is enabled)
data "aws_kms_alias" "eks_default" {
  count = var.enable_cluster_encryption && var.kms_key_arn == "" && var.kms_key_alias == "" ? 1 : 0
  name  = "alias/aws/eks"
}

# Get current AWS account and region info
data "aws_caller_identity" "current" {}
data "aws_region" "current" {}

# Auto-discover availability zones
data "aws_availability_zones" "available" {
  state = "available"
}

# ========================================
# LOCAL VARIABLES
# ========================================
locals {
  cluster_name = var.cluster_name
  common_tags = merge(var.common_tags, {
    ManagedBy   = "Terragrunt"
    Environment = var.environment
    Project     = var.project_name
  })
  
  # Smart defaults with auto-discovery priority:
  # 1. Explicit ID/ARN (highest priority)
  # 2. Discovery by name/alias
  # 3. AWS defaults (fallback)
  resolved_vpc_id = var.vpc_id != "" ? var.vpc_id : (
    var.vpc_name != "" ? try(data.aws_vpc.by_name[0].id, "") : try(data.aws_vpc.default[0].id, "")
  )
  
  # KMS key resolution - only attempt discovery when encryption is enabled
  resolved_kms_key_arn = var.enable_cluster_encryption ? (
    var.kms_key_arn != "" ? var.kms_key_arn : (
      var.kms_key_alias != "" ? try(data.aws_kms_alias.by_name[0].target_key_arn, "") : try(data.aws_kms_alias.eks_default[0].target_key_arn, "")
    )
  ) : ""
}

# ========================================
# STAGE 1: VPC DATA DISCOVERY
# ========================================
module "vpc_data" {
  count  = var.enable_stage_01_vpc ? 1 : 0
  source = "../vpc-data"

  vpc_id              = local.resolved_vpc_id
  private_subnet_tags = var.private_subnet_tags
  public_subnet_tags  = var.public_subnet_tags
  use_name_filter     = var.use_name_filter
  validate_network    = var.validate_network
}

# ========================================
# STAGE 2: BASTION HOST (CONDITIONAL)
# ========================================
# Note: Bastion module temporarily disabled due to submodule path issues
# module "bastion" {
#   count  = var.enable_bastion ? 1 : 0
#   source = "../bastion"
# 
#   depends_on = [module.vpc_data]
# 
#   # Deployment control
#   create_new_bastion   = var.bastion_create_new
#   create_eks_access_sg = var.bastion_create_eks_access_sg
#   create_ssm_documents = var.bastion_create_ssm_documents
# 
#   # Basic configuration
#   bastion_name = "${local.cluster_name}-bastion"
#   bastion_os   = var.bastion_os
#   bastion_ami  = var.bastion_ami
# 
#   # Instance configuration
#   instance_type = var.bastion_instance_type
#   key_pair_name = var.bastion_key_pair_name
# 
#   # Network configuration
#   vpc_id            = try(module.vpc_data[0].vpc_id, var.vpc_id)
#   vpc_cidr          = var.bastion_vpc_cidr
#   subnet_id         = var.bastion_subnet_id != "" ? var.bastion_subnet_id : try(module.vpc_data[0].public_subnet_ids[0], "")
#   availability_zone = var.bastion_availability_zone
# 
#   # Security configuration
#   allowed_cidr_blocks = var.bastion_allowed_cidr_blocks
#   ssh_port            = var.bastion_ssh_port
# 
#   # EKS integration
#   cluster_name    = local.cluster_name
#   kubectl_version = var.bastion_kubectl_version
#   region          = var.region
# 
#   # Environment metadata
#   environment  = var.environment
#   project_name = var.project_name
# 
#   # Tagging
#   common_tags = local.common_tags
# }

# ========================================
# STAGE 3: EKS CLUSTER
# ========================================
module "eks_cluster" {
  count   = var.enable_stage_02_cluster || var.enable_stage_03_cluster ? 1 : 0
  source  = "../eks-cluster"
  enabled = true

  depends_on = [module.vpc_data]

  # Basic cluster configuration
  cluster_name = local.cluster_name
  project_name = var.project_name
  environment  = var.environment

  # Cluster version and endpoint settings
  cluster_version         = var.cluster_version
  endpoint_private_access = var.endpoint_private_access
  endpoint_public_access  = var.endpoint_public_access
  public_access_cidrs     = var.public_access_cidrs

  # Networking configuration from Stage 1 VPC Discovery
  vpc_id             = try(module.vpc_data[0].vpc_id, var.vpc_id)
  private_subnet_ids = try(module.vpc_data[0].private_subnet_ids, [])
  subnet_ids         = try(module.vpc_data[0].private_subnet_ids, [])

  # Private access security configuration
  create_private_access_sg      = var.eks_create_private_access_sg
  private_access_cidrs          = var.eks_private_access_cidrs
  additional_security_group_ids = var.eks_additional_security_group_ids
  
  # Bastion security groups (disabled since bastion module is commented out)
  bastion_security_group_ids = []

  # Encryption configuration (using resolved KMS key)
  cluster_encryption_config = var.enable_cluster_encryption && local.resolved_kms_key_arn != "" ? [{
    provider_key_arn = local.resolved_kms_key_arn
    resources        = ["secrets"]
  }] : []

  # Resource tagging
  tags = local.common_tags
}

# ========================================
# STAGE 4: EKS NODE GROUPS
# ========================================
module "eks_nodegroup" {
  count   = var.enable_stage_03_nodes || var.enable_stage_04_nodes ? 1 : 0
  source  = "../eks-nodegroup"
  enabled = true

  depends_on = [module.eks_cluster]

  cluster_name       = local.cluster_name
  environment        = var.environment
  node_group_name    = "${local.cluster_name}-general"
  kubernetes_version = var.cluster_version

  subnet_ids = try(module.vpc_data[0].private_subnet_ids, [])

  instance_types = var.node_instance_types_general
  capacity_type  = var.capacity_type
  ami_type       = "AL2023_x86_64_STANDARD"
  disk_size      = var.disk_size

  desired_size = var.node_desired_size_general
  min_size     = var.node_min_size_general
  max_size     = var.node_max_size_general

  labels = {
    "node-type"   = "general"
    "environment" = var.environment
  }

  tags = local.common_tags
}

# ========================================
# STAGE 5: EKS ADDONS
# ========================================
module "eks_addons" {
  count   = var.enable_stage_04_addons || var.enable_stage_05_addons ? 1 : 0
  source  = "../eks-addons"
  enabled = true

  depends_on = [module.eks_cluster, module.eks_nodegroup]

  cluster_name      = local.cluster_name
  cluster_version   = var.cluster_version
  oidc_provider_arn = var.oidc_provider_arn

  node_groups_ready = var.enable_stage_03_nodes || var.enable_stage_04_nodes
  region            = var.region

  # Core addons
  enable_vpc_cni        = var.enable_vpc_cni
  enable_coredns        = var.enable_coredns
  enable_kube_proxy     = var.enable_kube_proxy
  enable_ebs_csi_driver = var.enable_ebs_csi_driver

  create_irsa_roles = var.create_irsa_roles
  tags              = local.common_tags
}

# ========================================
# STAGE 6: MONITORING (OPTIONAL)
# ========================================
module "monitoring" {
  count  = var.enable_stage_05_monitoring || var.enable_stage_06_monitoring ? 1 : 0
  source = "../monitoring"

  depends_on = [module.eks_addons]

  # Required parameters
  cluster_name = local.cluster_name
  environment  = var.environment

  # Monitoring configuration
  monitoring_namespace     = var.monitoring_namespace
  enable_prometheus       = var.enable_prometheus
  grafana_admin_password  = var.grafana_admin_password

  # Kong configuration
  enable_kong             = var.enable_kong
  kong_proxy_service_type = var.kong_proxy_service_type
  kong_admin_service_type = var.kong_admin_service_type

  # Storage configuration
  prometheus_storage_size = var.prometheus_storage_size
  grafana_storage_size    = var.grafana_storage_size

  # Ingress configuration
  grafana_ingress_enabled = var.grafana_ingress_enabled
  grafana_ingress_host    = var.grafana_ingress_host
}
